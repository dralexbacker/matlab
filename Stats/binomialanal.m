function [realpval] = binomialanal(p1,p2,N1,N2,precision)
% BINOMIALanal - Yields the p that the same underlying distribution generated two experiments with success probability differing 
%equally or more than the difference between p1 and p2, the number of successes in each experiment 
% (also works with p1 & p2 probabilities) 
% Analytical version. See also BINOMIALITER.
% AB Aug 01
% [realpval] = binomialanal(NS1,NS2,N1,N2,precision)
%
% NS1 & NS2 (integers) are the two numbers of successes being compared to see if they can come from the same underlying distribution
%   They represent the two 'conditions'.
% N1 & N2 are the # of experiments for p1 & p2, respectively. Default N2=N1.
%
% REALPVAL returns the p-value for the null hypothesis that both experiments were generated by the same underlying distribution.
%
% Note that REALPVAL is not only a function of abs(p1-p2), N1 and N2, but rather also of p1 & p2, because the relative probabilities
% of different underlying success probabilities are different for different p1 & p2 pairs even for constant difference:
% More extreme values of p1 & p2 indicate more consistent processes with smaller variances, and thus the probability of observing the
% same difference by chance gets smaller as p1 & p2 get away from 0.5

% Takes p(underlying prob==X | p1 & p2) = p(p1 & p2 | underlying prob==X)
%
% This is the binomail one to use.
% Binomialsimpleconservative is a simplification taking the most probable scenario, namely that the underlying p is halfway between p1 & p2, 
% and thus yields higher pvalues.
% Binomial extremes was written for testing purposes only and uses the prob that an observation is equal or greater in magnitude from the actual observation given 
% a given underlying probability as an estimate for the probability of that underlying prob given the observations. Binomialdiffn & Binomial, in contrast, uses the probability of the observation
% being closer to the actual observation given a PRECISION.
% Binomial requires N1=N2.

if nargin<4,
    N2=N1;
end
if nargin<5,
    precision=.1;
end

% If given success probabilities, convert to # of successes:
if (p1~=floor(p1) | p2~=floor(p2) | p1==0 | p2==0) & 0<=p1 & p1<=1 & 0<=p2 & p2<=1,
    p1=round(p1*N1);
    p2=round(p2*N2);
elseif p1~=floor(p1) | p2~=floor(p2),
    error('BINOMIALANAL requires integer number of successes as inputs')
elseif p1>N1 | p2>N2,
    error('BINOMIALANAL: # of successes must be <= # of trials')
elseif p1<0 | p2<0,
    error('BINOMIALANAL: p1 & p2 cannot be negative')
end
if N1~=floor(N1) | N2~=floor(N2),
    error('BINOMIALANAL requires integer number of # of experiments as inputs') 
end

dif=abs(p2-p1); % prob difference observed

k=0;
for m=0:precision:1, % These are continuous, not discrete, because they are the true underlying distribution, which is independent of N1 & N2
    k=k+1;
    p12=m; % p of getting a head:
    
    % Prob of getting a larger difference of p's than observed given underlying success prob is p12:
    pvalue(k)=binodifcdf(dif,p12,N1,N2);
    
    % Prob of underlying success prob being p12 given p1 & p2 observed:
    pp1= binopdfab(p1,N1,p12); %  length(find(abs(pr1-p1)<precision))/Niter; % If you use binopdf & binocdf, you get NaN when using p12=0 &/or 1
    pp2= binopdfab(p2,N2,p12); %length(find(abs(pr2-p2)<precision))/Niter;
    pp(k)=pp1*pp2;
    
end
totp=sum(pp);
realpval=sum(pp.*pvalue)/totp;

% Could return pp & pvalue as well
% PP & PVALUE are intermediates used to compute REALPVAL.
